{
  "name": "Redux-inputs",
  "tagline": "redux-inputs is a Javascript library that works with redux to validate and store values from inputs and forms.",
  "body": "# redux-inputs\r\n[![npm version](https://badge.fury.io/js/redux-inputs.svg)](https://badge.fury.io/js/redux-inputs) \r\n[![Build Status](https://travis-ci.org/zillow/redux-inputs.svg?branch=master)](https://travis-ci.org/zillow/redux-inputs)\r\n\r\n`redux-inputs` works with redux to validate and store values from inputs and forms.\r\nIt primarily consists of a redux reducer creator function and function to get\r\n a set of properties to be used by input components.\r\nBoth the reducer and input props creator take a inputConfig object that defines how inputs\r\n are initialized and validated.\r\n\r\n### Example\r\n\r\n    const inputConfig = {\r\n        homePrice: {\r\n            defaultValue: 300000,\r\n            validator: (value) => value > 0 && value < 350000000\r\n        }\r\n    }\r\n\r\n[*View the `inputConfig` API here*](INPUTCONFIG.md)\r\n\r\n## Installation\r\n\r\n`npm install --save redux-inputs`\r\n\r\n## Getting Started\r\n\r\nTo set up redux-inputs, there are three steps:\r\n\r\n### Step 1\r\n\r\nAdd [redux-thunk](https://github.com/gaearon/redux-thunk) middleware to your store,\r\n following instructions at that repo.\r\n\r\n### Step 2\r\n\r\nCreate an input configuration object and add a redux-inputs reducer to your redux\r\n store in your project's reducers file.\r\n\r\n    import { combineReducers } from 'redux';\r\n    import { createInputsReducer } from 'redux-inputs';\r\n\r\n    const inputConfig = { email: {} };\r\n    const reducer = combineReducers({\r\n        inputs: createInputsReducer(inputConfig)\r\n    });\r\n\r\nNote that `inputs` is the default mount point for redux-inputs state. You can\r\n configure this in your `inputConfig` object.\r\n\r\n    inputConfig = {\r\n        _form: {\r\n            reduxMountPoint: 'loginModal.userInputs'\r\n        }\r\n        ... other inputs config ...\r\n    }\r\n\r\nIn this example your state would look like this:\r\n\r\n    {\r\n        loginModal: {\r\n            userInputs: { ... }\r\n        }\r\n    }\r\n\r\n### Step 3 - Provide props to input components\r\n\r\nThe standard state format for an input in redux looks like this:\r\n\r\n    inputs: {\r\n        email: {\r\n            value: 'test@test.com',\r\n            error: '244535'\r\n        }\r\n    }\r\n\r\nThis represents a form with one input where the user first typed 'test@test.com',\r\n but changed it to '244535', which is invalid. This state is what you get when you\r\n use redux connect into your component.\r\n\r\nIn your connected component, use the `getInputProps` function to get an object with\r\n the following shape:\r\n    {\r\n        value: The last valid state the input had.\r\n        error: The state of the input if invalid, undefined otherwise. Should be displayed as value if present.\r\n        dispatchChange: A function to call on input changes to update the store\r\n    }\r\n\r\nThe following example uses React, though it is not strictly required.\r\n```jsx\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport { createStore, combineReducers, applyMiddleware } from 'redux';\r\nimport { createInputsReducer, getInputProps } from 'redux-inputs';\r\nimport { connect, Provider } from 'react-redux';\r\nimport thunk = from 'redux-thunk';\r\n\r\nconst inputConfig = { \r\n\temail: {\r\n\t\tdefaultValue: 'test@example.com',\r\n\t\tvalidator: (value) => typeof value === 'string' && value.indexOf('@') >= 0\r\n\t} \r\n};\r\nconst reducer = combineReducers({\r\n    inputs: createInputsReducer(inputConfig)\r\n});\r\nconst store = createStore(reducer, applyMiddleware(thunk));\r\n\r\nfunction Form(props) {\r\n\t  const { dispatch, inputs } = props;\r\n    const inputProps = getInputProps(inputConfig, inputs, dispatch);\r\n    const isEmailError = inputs.email.error;\r\n    return (\r\n        <form>\r\n            <input id=\"email\"\r\n                   value={inputProps.email.value}\r\n                   onChange={(e) => {\r\n                       inputProps.email.dispatchChange({ email: e.target.value })\r\n                   }} />\r\n             { isEmailError? <p className=\"error\">Your email must contain an @</p> : null}\r\n             <h3>Input state</h3>\r\n             <pre>{JSON.stringify(inputs, null, 2)}</pre>      \r\n        </form>\r\n    )\r\n}\r\nconst FormContainer = connect(s => s)(Form);\r\nReactDOM.render(<Provider store={store}><FormContainer /></Provider>, document.getElementById('container'));\r\n```\r\n[Interactive Demo](https://jsfiddle.net/jakepusateri/4sfkp9j7/5/)\r\n\r\nThe object passed to dispatchChange can have any number of key-value pairs in it.\r\n\r\n`dispatchChange` also returns a promise for when async validation runs and you want to handle the result after it's done.\r\n\r\nWith this set up, you are able make changes to inputs and have them declaratively\r\n validated and state synchronized with your store. Because this could send actions\r\n to your store every keystroke, you probably want to use something like a\r\n [BlurInput](http://khan.github.io/react-components/#blur-input).\r\n\r\nBy keeping these two redux-inputs functions flexible, it is easy to have multiple\r\n forms by making multiple inputConfigs. You can also make dynamic forms by\r\n dynamically creating input configs, replacing reducers, and creating dynamic components.\r\n\r\n## Components in React\r\n### `ReduxInputsWrapper`\r\nTo facilitate using redux-inputs with React, a higher order component `ReduxInputsWrapper`\r\n is provided that adds additional props to the wrapped component:\r\n\r\n - `parser`: Function to turn a value from a 'change' event into a logical value to be stored\r\n - `formatter`: Function to create a DOM-appropriate string from a value\r\n - `resolve`: Function that will be called after value changes have been set in the store\r\n - `reject`: Function that will be called if value changes fail validation\r\n\r\n#### Arguments\r\n- `WrappedComponent` *(Component)*\r\n- `options` *(Object)*\r\n- - `onChangeTransform` *(Function)* [optional] Turn a browser change event into a value. (e.g. `e => e.target.value` for `input`)\r\n\r\n\r\n## Other Actions Creators\r\n\r\n### `setInputs(inputConfig, change)`\r\n\r\nCreates an action that sets inputs state directly without validation.\r\n\r\n#### Arguments\r\n- `inputConfig` *(Object)*\r\n- `change` *(Object)*\r\n\r\nExample change:\r\n\r\n    {\r\n        email: {\r\n            value: 'test@test.com'\r\n            error: '1234'\r\n        },\r\n        name: {\r\n            value: 'larry'\r\n        }\r\n    }\r\n\r\n### `validateInputs(inputConfig, ?inputKeys)`\r\n\r\nA thunk that returns a Promise which resolves if all inputs are valid, rejects if one or more inputs are invalid.\r\nTriggers errors on inputs.\r\nresolve function is passed the input states of inputs that were validated\r\nreject function is passed the input states of inputs that are invalid\r\n\r\n#### Arguments\r\n- `inputConfig` *(Object)*\r\n- `inputKeys` *(Array)* [optional] Array of input keys found in inputConfig. If no inputKeys are given, validates all inputs found in inputConfig.\r\n\r\n### `resetInputs(inputConfig)`\r\n\r\nReturns an action that when dispatched will reset the form values associated with the given inputConfig to their default values.\r\n\r\n## Contributing\r\n\r\n### Build\r\n\r\n    gulp\r\n\r\n### Tests\r\n\r\n    npm test\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}